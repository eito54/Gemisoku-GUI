<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemisoku-GUI スコアオーバーレイ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Next.jsのSortableListスタイルを完全再現 */
        
        /* 滑らかな虹色グラデーションアニメーション */
        @keyframes smoothRainbowBorder {
            0% {
                border-image: linear-gradient(90deg,
                    hsl(0, 100%, 50%), hsl(51, 100%, 50%), hsl(102, 100%, 50%),
                    hsl(153, 100%, 50%), hsl(204, 100%, 50%), hsl(255, 100%, 50%),
                    hsl(306, 100%, 50%), hsl(0, 100%, 50%)
                ) 1;
            }
            25% {
                border-image: linear-gradient(90deg,
                    hsl(90, 100%, 50%), hsl(141, 100%, 50%), hsl(192, 100%, 50%),
                    hsl(243, 100%, 50%), hsl(294, 100%, 50%), hsl(345, 100%, 50%),
                    hsl(36, 100%, 50%), hsl(90, 100%, 50%)
                ) 1;
            }
            50% {
                border-image: linear-gradient(90deg,
                    hsl(180, 100%, 50%), hsl(231, 100%, 50%), hsl(282, 100%, 50%),
                    hsl(333, 100%, 50%), hsl(24, 100%, 50%), hsl(75, 100%, 50%),
                    hsl(126, 100%, 50%), hsl(180, 100%, 50%)
                ) 1;
            }
            75% {
                border-image: linear-gradient(90deg,
                    hsl(270, 100%, 50%), hsl(321, 100%, 50%), hsl(12, 100%, 50%),
                    hsl(63, 100%, 50%), hsl(114, 100%, 50%), hsl(165, 100%, 50%),
                    hsl(216, 100%, 50%), hsl(270, 100%, 50%)
                ) 1;
            }
            100% {
                border-image: linear-gradient(90deg,
                    hsl(360, 100%, 50%), hsl(51, 100%, 50%), hsl(102, 100%, 50%),
                    hsl(153, 100%, 50%), hsl(204, 100%, 50%), hsl(255, 100%, 50%),
                    hsl(306, 100%, 50%), hsl(360, 100%, 50%)
                ) 1;
            }
        }


        /* 躍動感のある加算得点アニメーション */
        @keyframes dynamicAddedScoreFloat {
            0% {
                opacity: 0;
                transform: translateY(15px) scale(0.7) rotateZ(5deg);
            }
            15% {
                opacity: 0.8;
                transform: translateY(-3px) scale(1.2) rotateZ(-2deg);
            }
            30% {
                opacity: 1;
                transform: translateY(0) scale(1) rotateZ(0deg);
            }
            70% {
                opacity: 1;
                transform: translateY(-2px) scale(1.05) rotateZ(0deg);
            }
            85% {
                opacity: 0.8;
                transform: translateY(-8px) scale(1.1) rotateZ(2deg);
            }
            100% {
                opacity: 0;
                transform: translateY(-20px) scale(0.8) rotateZ(-5deg);
            }
        }

        .added-score-float {
            animation: dynamicAddedScoreFloat 3.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            text-shadow: 0 0 8px rgba(34, 197, 94, 0.8);
        }

        .animated-parallelogram-border::before {
            content: '';
            position: absolute;
            inset: -1.5px;
            z-index: 0;
            background: linear-gradient(to right, rgba(15, 23, 42, 0.95), rgba(30, 58, 138, 0.9));
            border-width: 2px;
            border-style: solid;
            border-color: #fbbf24; /* 黄色の単色 */
            transform: skewX(-12deg);
            box-shadow: 0 1px 2px 0 rgba(251, 191, 36, 0.4), 0 1px 3px 0 rgba(251, 191, 36, 0.4);
            border-radius: 0.25rem;
        }

        .static-parallelogram-border::before {
            content: '';
            position: absolute;
            inset: -1.5px;
            z-index: 0;
            background: linear-gradient(to right, rgba(15, 23, 42, 0.95), rgba(30, 58, 138, 0.9));
            border-width: 2px;
            border-style: solid;
            border-color: rgba(59, 130, 246, 0.7);
            transform: skewX(-12deg);
            box-shadow: 0 1px 2px 0 rgba(96, 165, 250, 0.4), 0 1px 3px 0 rgba(96, 165, 250, 0.4);
            border-radius: 0.25rem;
        }

        /* 強化された緑色点滅エフェクト */
        @keyframes enhancedGreenFlash {
            0% {
                border-color: rgba(59, 130, 246, 0.7);
                box-shadow: 0 1px 2px 0 rgba(96, 165, 250, 0.4), 0 1px 3px 0 rgba(96, 165, 250, 0.4);
                background: linear-gradient(to right, rgba(15, 23, 42, 0.95), rgba(30, 58, 138, 0.9));
            }
            25% {
                border-color: rgba(34, 197, 94, 1);
                box-shadow: 0 0 15px 4px rgba(34, 197, 94, 0.9), 0 0 25px 8px rgba(34, 197, 94, 0.5);
                background: linear-gradient(to right, rgba(22, 101, 52, 0.95), rgba(34, 197, 94, 0.9));
            }
            50% {
                border-color: rgba(74, 222, 128, 1);
                box-shadow: 0 0 20px 6px rgba(74, 222, 128, 1), 0 0 35px 12px rgba(74, 222, 128, 0.6);
                background: linear-gradient(to right, rgba(22, 101, 52, 0.95), rgba(74, 222, 128, 0.9));
            }
            75% {
                border-color: rgba(34, 197, 94, 1);
                box-shadow: 0 0 15px 4px rgba(34, 197, 94, 0.9), 0 0 25px 8px rgba(34, 197, 94, 0.5);
                background: linear-gradient(to right, rgba(22, 101, 52, 0.95), rgba(34, 197, 94, 0.9));
            }
            100% {
                border-color: rgba(59, 130, 246, 0.7);
                box-shadow: 0 1px 2px 0 rgba(96, 165, 250, 0.4), 0 1px 3px 0 rgba(96, 165, 250, 0.4);
                background: linear-gradient(to right, rgba(15, 23, 42, 0.95), rgba(30, 58, 138, 0.9));
            }
        }

        .score-flash-active::before {
            animation: enhancedGreenFlash 0.6s cubic-bezier(0.4, 0, 0.6, 1) 2;
            animation-fill-mode: forwards;
        }
        
        /* アニメーション終了後にクラスを削除するためのスタイル */
        .score-flash-active {
            animation-duration: 1.2s; /* 0.6s × 2回 */
            animation-fill-mode: forwards;
        }

        @keyframes fadeInOut {
            0%, 100% {
                opacity: 0;
                transform: translateY(5px);
            }
            20%, 80% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .added-score-indicator {
            animation: fadeInOut 2s ease-in-out forwards;
        }

        /* 躍動感のあるスライドインアニメーション */
        @keyframes dynamicSlideInFromRight {
            0% {
                opacity: 0;
                transform: translateX(40px) scale(0.8) rotateY(15deg);
            }
            50% {
                opacity: 0.8;
                transform: translateX(-5px) scale(1.05) rotateY(-3deg);
            }
            100% {
                opacity: 1;
                transform: translateX(0) scale(1) rotateY(0deg);
            }
        }

        .slide-in-initial {
            animation: dynamicSlideInFromRight 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }

        /* 躍動感のあるフェードイン/アウトアニメーション */
        @keyframes dynamicFadeInOverlay {
            0% {
                opacity: 0;
                transform: scale(0.85) rotateX(10deg);
            }
            50% {
                opacity: 0.7;
                transform: scale(1.05) rotateX(-2deg);
            }
            100% {
                opacity: 1;
                transform: scale(1) rotateX(0deg);
            }
        }

        @keyframes dynamicFadeOutOverlay {
            0% {
                opacity: 1;
                transform: scale(1) rotateX(0deg);
            }
            50% {
                opacity: 0.7;
                transform: scale(1.03) rotateX(5deg);
            }
            100% {
                opacity: 0;
                transform: scale(0.9) rotateX(-10deg);
            }
        }

        .overlay-fade-in {
            animation: dynamicFadeInOverlay 1.0s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            opacity: 1;
            transform: scale(1) rotateX(0deg);
        }

        .overlay-fade-out {
            animation: dynamicFadeOutOverlay 0.6s ease-in-out forwards;
            opacity: 0;
            transform: scale(0.9) rotateX(-10deg);
        }

        /* 滑らかな順位変動スライドアニメーション */
        @keyframes smoothSlideToPosition {
            0% {
                transform: translateY(var(--start-y, 0));
            }
            100% {
                transform: translateY(var(--end-y, 0));
            }
        }

        .position-slide {
            animation: smoothSlideToPosition 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }

        /* 順位変動中の要素を一時的に固定位置にする */
        .sliding-element {
            position: relative;
            z-index: 10;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        body {
            background: transparent;
            overflow: hidden;
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
        }

        #scores-container {
            opacity: 1;
            transform: scale(1);
        }

        .no-data {
            color: #cccccc;
            text-align: center;
            font-style: italic;
            padding: 20px;
        }

        /* 非オーバーレイモード（テスト用） */
        body:not(.overlay-mode) {
            background: #1e293b;
            padding: 20px;
        }

        /* 残りレース数表示のアニメーション */
        @keyframes remainingRacesPulse {
            0%, 100% {
                opacity: 0.8;
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4);
            }
            50% {
                opacity: 1;
                box-shadow: 0 0 0 4px rgba(59, 130, 246, 0);
            }
        }

    </style>
</head>
<body>
    <div class="w-full mx-auto mt-8 bg-transparent" id="scores-container">
        <div class="no-data">スコアデータがありません</div>
    </div>

    <script>
        // URLパラメータでオーバーレイモードかどうかを判定
        const urlParams = new URLSearchParams(window.location.search);
        const isOverlayMode = urlParams.get('overlay') === 'true';
        
        if (isOverlayMode) {
            document.body.classList.add('overlay-mode');
        }

        let selectedTeamInfo = null;
        let previousTeamOrder = []; // 前回のチーム順序を保存
        let hasDataEverLoaded = false; // データが一度でも読み込まれたかのフラグ

        // チーム選択の切り替え
        function toggleTeamSelection(teamName) {
            if (selectedTeamInfo && selectedTeamInfo.name === teamName) {
                selectedTeamInfo = null;
            } else {
                selectedTeamInfo = { name: teamName };
            }
            updateScores(); // 即座に更新
        }

        let previousRemainingRaces = null;

        // 残りレース数を更新する関数
        function updateRemainingRaces(remainingRaces, showRemainingRaces = true) {
            const remainingRacesContainer = document.getElementById('remaining-races-container');
            
            // 設定で無効になっている場合は表示しない
            if (!showRemainingRaces || remainingRaces === undefined || remainingRaces === null) {
                if (remainingRacesContainer) {
                    remainingRacesContainer.style.display = 'none';
                }
                previousRemainingRaces = null;
                return;
            }
            
            if (remainingRacesContainer) {
                remainingRacesContainer.style.display = 'flex';
                
                // 残りレース数が0の場合は異なる表示
                if (remainingRaces === 0) {
                    remainingRacesContainer.innerHTML = `
                        <div class="relative static-parallelogram-border overflow-visible">
                            <div class="flex items-center gap-1 px-2 py-1 text-sm font-bold text-white relative z-10">
                                <svg class="h-3 w-3 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                </svg>
                                <span class="text-green-400 text-xs">完了</span>
                            </div>
                        </div>
                    `;
                } else {
                    remainingRacesContainer.innerHTML = `
                        <div class="relative static-parallelogram-border overflow-visible">
                            <div class="flex items-center gap-1 px-2 py-1 text-sm font-bold text-white relative z-10">
                                <svg class="h-3 w-3 text-blue-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                </svg>
                                <span class="text-xs">残り${remainingRaces}</span>
                            </div>
                        </div>
                    `;
                }
            }
            
            previousRemainingRaces = remainingRaces;
        }

        // スコアデータを取得して表示（アニメーション対応版）
        async function updateScores() {
            try {
                const response = await fetch('/api/scores');
                const data = await response.json();
                const scores = data.scores || [];
                const remainingRaces = data.remainingRaces;
                const showRemainingRaces = data.showRemainingRaces !== false; // デフォルトはtrue
                
                // 初回読み込み時は常に表示、その後はスコア変動があった場合のみ更新
                if (!hasDataEverLoaded) {
                    updateRemainingRaces(remainingRaces, showRemainingRaces);
                }
                
                const container = document.getElementById('scores-container');
                
                if (scores.length === 0) {
                    // データがない場合
                    container.classList.remove('overlay-fade-out', 'overlay-fade-in');
                    container.innerHTML = '<div class="no-data">スコアデータがありません</div>';
                    // データがない場合は残りレース数表示を隠す
                    updateRemainingRaces(null, showRemainingRaces);
                    return;
                }
                
                // スコアでソート（降順）
                scores.sort((a, b) => b.score - a.score);
                
                // 現在のチーム順序を取得
                const currentTeamOrder = scores.map(team => team.team);
                
                // 順位変動を検出
                const hasRankingChanged = hasDataEverLoaded &&
                    previousTeamOrder.length > 0 &&
                    !currentTeamOrder.every((team, index) => team === previousTeamOrder[index]);
                
                // isCurrentPlayerを持つチームを自動選択
                const currentPlayerTeam = scores.find(team => team.isCurrentPlayer);
                if (currentPlayerTeam && (!selectedTeamInfo || selectedTeamInfo.name !== currentPlayerTeam.team)) {
                    selectedTeamInfo = { name: currentPlayerTeam.team };
                }
                
                // 初回読み込み時または合計点計測時のフェードイン判定
                const shouldFadeIn = !hasDataEverLoaded || (data.isOverallUpdate === true);
                
                // フェードアウト（合計点計測時のみ）
                if (hasDataEverLoaded && shouldFadeIn) {
                    container.classList.add('overlay-fade-out');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    container.classList.remove('overlay-fade-out');
                }
                
                // 順位変動アニメーションの準備
                if (hasRankingChanged) {
                    await animateRankingChange(currentTeamOrder, scores, container);
                } else {
                    // 通常の更新
                    renderScoreList(scores, container);
                }
                
                // フェードイン（初回または合計点計測時）
                if (shouldFadeIn) {
                    container.classList.add('overlay-fade-in');
                    setTimeout(() => {
                        container.classList.remove('overlay-fade-in');
                    }, 800);
                } else {
                    // 通常更新時は既存のクラスをクリア
                    container.classList.remove('overlay-fade-out', 'overlay-fade-in');
                }
                
                // 前回の順序を保存
                previousTeamOrder = [...currentTeamOrder];
                hasDataEverLoaded = true;
                
            } catch (error) {
                console.error('スコア取得エラー:', error);
                const container = document.getElementById('scores-container');
                container.innerHTML = '<div class="no-data">スコア取得エラー</div>';
            }
        }

        // スコアリストをレンダリングする関数
        function renderScoreList(scores, container) {
            container.innerHTML = `
                <div class="space-y-0 w-full max-w-md mx-auto relative">
                    <!-- 残りレース数表示（1位チームの左側に独立配置） -->
                    <div id="remaining-races-container" class="absolute left-0 top-0 z-10" style="display: none; transform: translateX(-70px);">
                        <!-- 動的に内容が挿入される -->
                    </div>
                    
                    ${scores.map((team, index) => {
                        const isTeamSelected = selectedTeamInfo && selectedTeamInfo.name === team.team;
                        const myTeam = selectedTeamInfo ? scores.find(s => s.team === selectedTeamInfo.name) : undefined;
                        
                        // 差分計算
                        let diffDisplay = '';
                        if (selectedTeamInfo && myTeam && !isTeamSelected) {
                            const scoreDiff = myTeam.score - team.score;
                            const diffText = scoreDiff === 0 ? "0" : scoreDiff > 0 ? `+${scoreDiff}` : `${scoreDiff}`;
                            const textColor = scoreDiff > 0 ? 'text-green-400' : scoreDiff < 0 ? 'text-red-400' : 'text-white';
                            const iconColor = scoreDiff > 0 ? 'text-green-400' : scoreDiff < 0 ? 'text-red-400' : 'text-blue-300';
                            diffDisplay = `
                                <div class="relative static-parallelogram-border overflow-visible">
                                    <div class="flex items-center gap-1 px-1.5 py-0.5 text-sm font-bold ${textColor} relative z-10">
                                        <svg class="h-3 w-3 ${iconColor}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"/>
                                        </svg>
                                        <span>${diffText}</span>
                                    </div>
                                </div>
                            `;
                        } else if (!selectedTeamInfo && index < scores.length - 1) {
                            const scoreDiff = scores[index].score - scores[index + 1].score;
                            const diffText = scoreDiff > 0 ? `+${scoreDiff}` : `${scoreDiff}`;
                            diffDisplay = `
                                <div class="relative static-parallelogram-border overflow-visible">
                                    <div class="flex items-center gap-1 px-1.5 py-0.5 text-sm font-bold text-white relative z-10">
                                        <svg class="h-3 w-3 text-blue-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"/>
                                        </svg>
                                        <span>${diffText}</span>
                                    </div>
                                </div>
                            `;
                        }
                        
                        return `
                            <div class="h-12 flex items-center gap-1 px-2 border-0 rounded-lg transition-all duration-200 cursor-pointer relative"
                                 ondblclick="toggleTeamSelection('${escapeHtml(team.team)}')"
                                 data-team-row="${escapeHtml(team.team)}">
                                
                                <!-- チーム名 -->
                                <div class="relative w-20 h-7 ${isTeamSelected ? 'animated-parallelogram-border' : 'static-parallelogram-border'} overflow-visible">
                                    <div class="relative z-20 w-full h-full flex items-center justify-center">
                                        <span class="text-center font-medium text-white whitespace-nowrap px-0.5" style="font-size: ${team.team.length <= 3 ? '0.75rem' : '0.6rem'}">
                                            ${escapeHtml(team.team)}
                                        </span>
                                    </div>
                                </div>
                                
                                <!-- スコアと差分表示のグループ -->
                                <div class="flex items-center gap-0.5">
                                    <!-- スコア -->
                                    <div class="relative w-16 h-7 score-box ${isTeamSelected ? 'animated-parallelogram-border' : 'static-parallelogram-border'} overflow-visible" data-team="${escapeHtml(team.team)}">
                                        <div class="relative z-20 w-full h-full flex items-center justify-center">
                                            <span class="text-base text-center font-medium text-white">
                                                ${team.score || 0}
                                            </span>
                                            <!-- 加算点数表示（スコア枠内の右側） -->
                                            ${team.addedScore && team.addedScore > 0 ? `
                                                <span class="absolute right-1 top-0 text-green-400 font-bold text-xs" data-added-score="${escapeHtml(team.team)}">
                                                    +${team.addedScore}
                                                </span>
                                            ` : ''}
                                        </div>
                                    </div>
                                    
                                    <!-- 差分スコア表示（スコア枠に隣接） -->
                                    ${diffDisplay}
                                </div>
                                
                                <!-- 右端のスペーサー -->
                                <div class="flex-1"></div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        // 順位変動アニメーション
        async function animateRankingChange(newOrder, scores, container) {
            const currentElements = container.querySelectorAll('[data-team-row]');
            const elementMap = new Map();
            const elementPositions = new Map();
            
            // 現在の要素の位置を記録
            currentElements.forEach((element, index) => {
                const teamName = element.getAttribute('data-team-row');
                elementMap.set(teamName, element);
                elementPositions.set(teamName, index * 48); // 48px = h-12のheight
            });
            
            // 新しい順序での位置を計算
            const newPositions = new Map();
            newOrder.forEach((teamName, index) => {
                newPositions.set(teamName, index * 48);
            });
            
            // アニメーション実行
            const animations = [];
            elementMap.forEach((element, teamName) => {
                const currentPos = elementPositions.get(teamName);
                const newPos = newPositions.get(teamName);
                
                if (currentPos !== newPos) {
                    const deltaY = newPos - currentPos;
                    element.style.setProperty('--start-y', '0px');
                    element.style.setProperty('--end-y', `${deltaY}px`);
                    element.classList.add('position-slide', 'sliding-element');
                    
                    animations.push(new Promise(resolve => {
                        element.addEventListener('animationend', () => {
                            element.classList.remove('position-slide', 'sliding-element');
                            element.style.removeProperty('--start-y');
                            element.style.removeProperty('--end-y');
                            resolve();
                        }, { once: true });
                    }));
                }
            });
            
            // すべてのアニメーションが完了するまで待機
            if (animations.length > 0) {
                await Promise.all(animations);
            }
            
            // アニメーション完了後に新しい内容を描画
            renderScoreList(scores, container);
        }

        // HTMLエスケープ関数
        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, function(m) { return map[m]; });
        }

        let previousScores = new Map(); // 前回のスコアを保存
        let isFirstLoad = true; // 初回読み込みフラグ

        // 新しいupdateScores関数にスコア変更アニメーション機能を統合
        const baseUpdateScores = updateScores;
        updateScores = async function() {
            try {
                await baseUpdateScores();
                
                // DOM更新後のスコア変更アニメーション制御
                setTimeout(async () => {
                    try {
                        const response = await fetch('/api/scores');
                        const data = await response.json();
                        const scores = data.scores || [];
                        const remainingRaces = data.remainingRaces;
                        const showRemainingRaces = data.showRemainingRaces !== false; // デフォルトはtrue
                        let hasScoreUpdate = false;
                        
                        // 残りレース数を更新（設定に基づいて制御）
                        updateRemainingRaces(remainingRaces, showRemainingRaces);
                        
                        // スコア変更アニメーション
                        scores.forEach(team => {
                            const prevScore = previousScores.get(team.team);
                            if (prevScore !== undefined && prevScore !== team.score && team.addedScore > 0) {
                                hasScoreUpdate = true;
                                
                                const scoreElement = document.querySelector(`[data-team="${team.team}"]`);
                                if (scoreElement) {
                                    scoreElement.classList.add('score-flash-active');
                                    setTimeout(() => {
                                        scoreElement.classList.remove('score-flash-active');
                                    }, 1200);
                                }
                            }
                            previousScores.set(team.team, team.score);
                        });
                        
                        // 加算得点アニメーション制御（DOM更新後）
                        setTimeout(() => {
                            scores.forEach(team => {
                                const prevScore = previousScores.get(team.team);
                                if (prevScore !== undefined && prevScore !== team.score && team.addedScore && team.addedScore > 0) {
                                    const addedScoreElement = document.querySelector(`[data-added-score="${team.team}"]`);
                                    if (addedScoreElement && !addedScoreElement.classList.contains('added-score-float')) {
                                        addedScoreElement.classList.add('added-score-float');
                                        
                                        // 3秒後に要素を削除
                                        setTimeout(() => {
                                            if (addedScoreElement.parentNode) {
                                                addedScoreElement.remove();
                                            }
                                        }, 3000);
                                    }
                                }
                            });
                        }, 200);
                        
                        
                        // スライドインアニメーション（初回のみ）
                        if (isFirstLoad) {
                            const teamRows = document.querySelectorAll('[data-team-row]');
                            teamRows.forEach((element, index) => {
                                element.classList.add('slide-in-initial');
                                element.style.animationDelay = `${index * 0.05}s`;
                            });
                            isFirstLoad = false; // 初回フラグをfalseに
                        }
                    } catch (fetchError) {
                        console.error('アニメーション用データ取得エラー:', fetchError);
                    }
                }, 100);
                
            } catch (error) {
                console.error('スコア取得エラー:', error);
                const container = document.getElementById('scores-container');
                if (container) {
                    container.innerHTML = '<div class="no-data">スコア取得エラー</div>';
                }
            }
        };

        // 初回読み込み
        updateScores();

        // SSE接続でリアルタイム更新
        function setupSSE() {
            const eventSource = new EventSource('/api/scores/events');
            
            eventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    if (data.type === 'scores-updated') {
                        console.log('Received score update notification');
                        updateScores();
                    }
                } catch (error) {
                    console.error('SSE message parsing error:', error);
                }
            };
            
            eventSource.onerror = function(error) {
                console.error('SSE connection error:', error);
                // 接続が失われた場合、5秒後に再接続を試行
                setTimeout(() => {
                    eventSource.close();
                    setupSSE();
                }, 5000);
            };
        }

        // SSE接続を開始
        setupSSE();
    </script>
</body>
</html>